#include "Sudoku.hpp"

//Private functions
void Sudoku::initWindow()
{
	this->videoMode.height = 700;
	this->videoMode.width = 1000;
	this->window = new sf::RenderWindow(this->videoMode, "Sudoku solver", sf::Style::Close | sf::Style::Titlebar);
	this->window->setFramerateLimit(60);
}

void Sudoku::initBoard()
{
	this->board.setPosition(0.f,0.f);
	this->board.setSize(sf::Vector2f(700.f, 700.f));
	this->boardTexture.loadFromFile("Textures/board.png");
	this->board.setTexture(&this->boardTexture);

	this->resetButton.setPosition(750.f, 500.f);
	this->resetButton.setSize(sf::Vector2f(200.f, 100.f));
	this->resetTexture.loadFromFile("Textures/reset.png");
	this->resetButton.setTexture(&this->resetTexture);

	this->stepButton.setPosition(750.f, 100.f);
	this->stepButton.setSize(sf::Vector2f(200.f, 100.f));
	this->stepTexture.loadFromFile("Textures/onestep.png");
	this->stepButton.setTexture(&this->stepTexture);

	this->solveButton.setPosition(750.f, 300.f);
	this->solveButton.setSize(sf::Vector2f(200.f, 100.f));
	this->solveTexture.loadFromFile("Textures/solve.png");
	this->solveButton.setTexture(&this->solveTexture);
}

void Sudoku::drawBoard()
{
	this->window->draw(this->board);
	this->window->draw(this->resetButton);
	this->window->draw(this->solveButton);
	this->window->draw(this->stepButton);
}

void Sudoku::initBoxes()
{
	this->greyColor = new sf::Color(186, 181, 181);
	for (int i = 0;i < 10;i++)
	{
		std::string t = "Textures/" + std::to_string(i) + ".png";
		boxTextures[i].loadFromFile(t);
	}

	int y = 14;
	for (int i = 0;i < 9;i++)
	{
		int x = 14;
		for (int j = 0;j < 9;j++)
		{
			box[i][j].setFillColor(sf::Color::White);
			box[i][j].setSize(sf::Vector2f(70.f, 70.f));
			box[i][j].setPosition(x, y);
			x += 74;
			if (j == 2 || j == 5)
				x += 5;
		}
		y += 74;
		if (i == 2 || i == 5)
			y += 5;
	}
}

void Sudoku::drawBoxes()
{
	for(int i = 0;i < 9;i++)
		for (int j = 0;j < 9;j++)
			this->window->draw(box[i][j]);
}

//Public functions
Sudoku::Sudoku()
{
	this->initWindow();
	this->initBoard();
	this->initBoxes();
}

Sudoku::~Sudoku()
{
	delete this->window;
}

const bool Sudoku::running() const
{
	return this->window->isOpen();
}

void Sudoku::poolEvent()
{
	while (this->window->pollEvent(this->ev))
	{
		switch (this->ev.type)
		{
		case sf::Event::Closed:
			this->window->close();
			break;
		case sf::Event::KeyPressed:
			if (ev.key.code == sf::Keyboard::Escape)
				this->window->close();
			break;
		}
	}
}

void Sudoku::updateMousePosition() //aktualizacja pozycji myszy wzglęcem okna
{
	this->mousePosition = this->window->mapPixelToCoords(sf::Mouse::getPosition(*this->window));
}

void Sudoku::updateButtons()
{
	if (this->resetButton.getGlobalBounds().contains(this->mousePosition))
		this->resetTexture.loadFromFile("Textures/reset-hover.png");
	else
		this->resetTexture.loadFromFile("Textures/reset.png");

	if (this->solveButton.getGlobalBounds().contains(this->mousePosition))
		this->solveTexture.loadFromFile("Textures/solve-hover.png");
	else
		this->solveTexture.loadFromFile("Textures/solve.png");

	if (this->stepButton.getGlobalBounds().contains(this->mousePosition))
		this->stepTexture.loadFromFile("Textures/onestep-hover.png");
	else
		this->stepTexture.loadFromFile("Textures/onestep.png");
}

void Sudoku::updateBoxes()
{
	static bool pressed = false;
	for (int i = 0;i < 9;i++)
	{
		for (int j = 0;j < 9;j++)
		{
			if (this->box[i][j].getGlobalBounds().contains(this->mousePosition) && sf::Mouse::isButtonPressed(sf::Mouse::Left) && !pressed)
			{
				pressed = true;
				if (this->checkedX == j && this->checkedY == i)
				{
					this->box[i][j].setFillColor(sf::Color::White);
					checkedX = -1;
					checkedY = -1;
				}
				else if(this->checkedX != -1 && this->checkedY != -1)
				{
					this->box[this->checkedY][this->checkedX].setFillColor(sf::Color::White);
					this->box[i][j].setFillColor(*this->greyColor);
					this->checkedX = j;
					this->checkedY = i;
				}
				else
				{
					this->box[i][j].setFillColor(*this->greyColor);
					this->checkedX = j;
					this->checkedY = i;
				}
			}
		}
	}
	if (this->ev.type == sf::Event::MouseButtonReleased)
		if (this->ev.mouseButton.button == sf::Mouse::Left)
			pressed = false;

	if ((sf::Keyboard::isKeyPressed(sf::Keyboard::Tab)) && !pressed)
	{
		pressed = true;
		if (this->checkedX == -1 && this->checkedY == -1)
		{
			this->box[0][0].setFillColor(*this->greyColor);
			this->checkedX = 0;
			this->checkedY = 0;
		}
		else if (this->checkedX == 8 && this->checkedY != 8)
		{
			this->box[this->checkedY][this->checkedX].setFillColor(sf::Color::White);
			this->checkedX = 0;
			this->checkedY++;
			this->box[this->checkedY][this->checkedX].setFillColor(*this->greyColor);
		}
		else if (this->checkedY == 8 && this->checkedX == 8)
		{
			this->box[this->checkedY][this->checkedX].setFillColor(sf::Color::White);
			this->checkedX = 0;
			this->checkedY = 0;
			this->box[this->checkedY][this->checkedX].setFillColor(*this->greyColor);
		}
		else
		{
			this->box[this->checkedY][this->checkedX].setFillColor(sf::Color::White);
			this->checkedX++;
			this->box[this->checkedY][this->checkedX].setFillColor(*this->greyColor);
		}
	}
	if (this->ev.type == sf::Event::KeyReleased)
		if (this->ev.mouseButton.button == sf::Keyboard::Tab)
			pressed = false;


	if (this->checkedX != -1 && this->checkedY != -1)
	{
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Num0))
		{
			this->box[this->checkedY][this->checkedX].setTexture(&boxTextures[0]);
			this->number[this->checkedY][this->checkedX] = 0;
		}
		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Num1))
		{	
			this->box[this->checkedY][this->checkedX].setTexture(&boxTextures[1]);
			this->number[this->checkedY][this->checkedX] = 1;
		}
		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Num2))
		{
			this->box[this->checkedY][this->checkedX].setTexture(&boxTextures[2]);
			this->number[this->checkedY][this->checkedX] = 2;
		}
		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Num3))
		{
			this->box[this->checkedY][this->checkedX].setTexture(&boxTextures[3]);
			this->number[this->checkedY][this->checkedX] = 3;
		}
		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Num4))
		{
			this->box[this->checkedY][this->checkedX].setTexture(&boxTextures[4]);
			this->number[this->checkedY][this->checkedX] = 4;
		}
		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Num5))
		{
			this->box[this->checkedY][this->checkedX].setTexture(&boxTextures[5]);
			this->number[this->checkedY][this->checkedX] = 5;
		}
		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Num6))
		{
			this->box[this->checkedY][this->checkedX].setTexture(&boxTextures[6]);
			this->number[this->checkedY][this->checkedX] = 6;
		}
		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Num7))
		{
			this->box[this->checkedY][this->checkedX].setTexture(&boxTextures[7]);
			this->number[this->checkedY][this->checkedX] = 7;
		}
		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Num8))
		{
			this->box[this->checkedY][this->checkedX].setTexture(&boxTextures[8]);
			this->number[this->checkedY][this->checkedX] = 8;
		}
		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Num9))
		{
			this->box[this->checkedY][this->checkedX].setTexture(&boxTextures[9]);
			this->number[this->checkedY][this->checkedX] = 9;
		}
	}
}

void Sudoku::menu()
{
	static bool pressed;
	if (this->stepButton.getGlobalBounds().contains(this->mousePosition) && sf::Mouse::isButtonPressed(sf::Mouse::Left) && !pressed)
	{
		pressed = true;
		//this->solve();
		this->findCandidate();

		for (int i = 0;i < 9;i++)
		{
			for (int j = 0;j < 9;j++)
			{
				for (int k = 0;k < cand[i][j].size();k++)
				{
					std::cout << cand[i][j][k] << " ";
				}
				std::cout << std::endl;
			}
		}
	}
	else if (this->solveButton.getGlobalBounds().contains(this->mousePosition) && sf::Mouse::isButtonPressed(sf::Mouse::Left) && !pressed)
	{
		pressed = true;
		while (true)
		{
			this->solve();
			int checked = 0;
			for (int i = 0;i < 9;i++)
				for (int j = 0;j < 9;j++)
					if (number[i][j] != 0)
							checked++;
			if (checked == 81 || this->error)
			{
				this->error = false;
				break;
			}
		}
	}
	if (this->ev.type == sf::Event::MouseButtonReleased)
		if (this->ev.mouseButton.button == sf::Mouse::Left)
			pressed = false;
}

void Sudoku::square(int b,int a) //rozwiązuje pojedynczy kwadrat w sudoku
{
	std::vector<int> searchNumbers = { 1,2,3,4,5,6,7,8,9 };
	for (int i = b;i < b+3;i++)
	{
		for (int j = a;j < a+3;j++)
		{
			for (int k = 0;k < searchNumbers.size();k++)
			{
				if (this->number[i][j] == searchNumbers[k])
				{
					searchNumbers.erase(searchNumbers.begin() + k);
					break;
				}
			}
		}
	}
	for (int k = 0;k < searchNumbers.size();k++)
	{
		bool free;
		int freeNumber = 0;
		int freeX, freeY;
		for (int i = b;i < b+3;i++)
		{
			for (int j = a;j < a+3;j++)
			{
				if (this->number[i][j] == 0)
				{
					free = true;
					for (int x = 0;x < 9;x++)
					{
						if (searchNumbers[k] == this->number[i][x])
						{
							free = false;
							break;
						}
					}
					for (int x = 0;x < 9;x++)
					{
						if (searchNumbers[k] == this->number[x][j])
						{
							free = false;
							break;
						}
					}
					if (free == true)
					{
						freeNumber++;
						freeX = j;
						freeY = i;
					}
				}
			}
		}
		if (freeNumber == 1)
		{
			this->box[freeY][freeX].setTexture(&boxTextures[searchNumbers[k]]);
			this->number[freeY][freeX] = searchNumbers[k];
			this->solved = true;			
			break;
		}
	}
}

bool Sudoku::existInSquare(int y,int x,int k)
{
	int a, b;
	if (x < 3)
		b = 0;
	else if (x >= 3 && x < 6)
		b = 3;
	else if (x >= 6)
		b = 6;

	if (y < 3)
		a = 0;
	else if (y >= 3 && y < 6)
		a = 3;
	else if (y >= 6)
		a = 6;

	for (int i = a;i < a + 3;i++)
		for (int j = b;j < b + 3;j++)
			if (number[i][j] == k)
				return true;
	return false;		
}

void Sudoku::lineX(int a)
{
	std::vector<int> searchNumbers = { 1,2,3,4,5,6,7,8,9 };
	for (int i = 0;i < 9;i++)
	{
		for (int k = 0;k < searchNumbers.size();k++)
		{
			if (this->number[a][i] == searchNumbers[k])
			{
				searchNumbers.erase(searchNumbers.begin() + k);
				break;
			}
		}
	}

	for (int k = 0;k < searchNumbers.size();k++)
	{
		bool free;
		int freeNumber = 0;
		int freeX;
		for (int j = 0;j < 9;j++)
		{
			if (this->number[a][j] == 0)
			{
				free = true;
				for (int i = 0;i < 9;i++)
				{
					if (this->number[i][j] == searchNumbers[k])
					{
						free = false;
						break;
					}
				}
				bool exist = false;
				if (this->existInSquare(j, a, searchNumbers[k]));
					exist = true;
			
				if (exist)
					free = false;

				if (free == true)
				{
					freeNumber++;
					freeX = j;
				}
			}
		}
		if (freeNumber == 1)
		{
			this->box[a][freeX].setTexture(&boxTextures[searchNumbers[k]]);
			this->number[a][freeX] = searchNumbers[k];
			this->solved = true;
			break;
		}
	}
}

void Sudoku::lineY(int a)
{
	std::vector<int> searchNumbers = { 1,2,3,4,5,6,7,8,9 };
	for (int i = 0;i < 9;i++)
	{
		for (int k = 0;k < searchNumbers.size();k++)
		{
			if (this->number[i][a] == searchNumbers[k])
			{
				searchNumbers.erase(searchNumbers.begin() + k);
				break;
			}
		}
	}

	for (int k = 0;k < searchNumbers.size();k++)
	{
		bool free;
		int freeNumber = 0;
		int freeY;
		for (int j = 0;j < 9;j++)
		{
			if (this->number[j][a] == 0)
			{
				free = true;
				for (int i = 0;i < 9;i++)
				{
					if (this->number[j][i] == searchNumbers[k])
					{
						free = false;
						break;
					}
				}
				bool exist = false;
				if (this->existInSquare(j, a, searchNumbers[k]))
					exist = true;

				if (exist)
					free = false;

				if (free == true)
				{
					freeNumber++;
					freeY = j;
				}
			}
		}
		if (freeNumber == 1)
		{
			this->box[freeY][a].setTexture(&boxTextures[searchNumbers[k]]);
			this->number[freeY][a] = searchNumbers[k];
			this->solved = true;
			break;
		}
	}
}

void Sudoku::findCandidate()
{
	std::vector<std::vector<std::vector<int>>>tab(9, std::vector<std::vector<int>>(9));
	
	for (int i = 0;i < 9;i++)
	{
		for (int j = 0;j < 9;j++)
		{
			if (this->number[i][j] != 0)
				tab[i][j].push_back(10);
			else
			{
				for (int k = 1;k <= 9;k++)
				{
					bool exist = false;
					for (int x = 0;x < 9;x++)
					{
						if (k == number[i][x])
						{
							exist = true;
							break;
						}
					}
					for (int x = 0;x < 9;x++)
					{
						if (k == number[x][j])
						{
							exist = true;
							break;
						}
					}
					if (this->existInSquare(i, j, k))
						exist = true;

					if (!exist)
						tab[i][j].push_back(k);
				}
			}		
		}
	}
	this->cand = tab;
}


void Sudoku::solve()
{
	for (int i = 0;i <= 6;i += 3)
	{
		for (int j = 0;j <= 6;j+=3)
		{
			if (!this->solved)
				this->square(i,j);
		}
	}

	for (int i = 0;i < 9;i++)
		if (!this->solved)
			this->lineX(i);

	for (int i = 0;i < 9;i++)
		if (!this->solved)
			this->lineY(i);

	if (!this->solved)
		this->error = true;
	this->solved = false;	
}

void Sudoku::reset()
{
	if (this->resetButton.getGlobalBounds().contains(this->mousePosition) && sf::Mouse::isButtonPressed(sf::Mouse::Left))
	{
		for (int i = 0;i < 9;i++)
		{
			for (int j = 0;j < 9;j++)
			{
				this->box[i][j].setTexture(&this->boxTextures[0]);
				this->number[i][j] = 0;
			}
		}
		this->findCandidate();
	}
}

void Sudoku::update()
{
	this->running();
	this->poolEvent();
	this->updateMousePosition();
	this->updateButtons();
	this->updateBoxes();
	this->menu();
	this->reset();
}

void Sudoku::render()
{
	this->window->clear();
	this->drawBoard();
	this->drawBoxes();
	this->window->display();
}
